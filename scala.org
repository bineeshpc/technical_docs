Scala trait
Similar to java interface

Similar to interfaces in Java, traits are used to define object 
types by specifying the signature of the supported methods.
http://docs.scala-lang.org/tutorials/tour/traits.html

* Scala Introduction
Scala, short for Scalable Language, is a hybrid functional programming language. It was created by Martin Odersky. Scala smoothly integrates the features of object-oriented and functional languages. Scala is compiled to run on the Java Virtual Machine. Many existing companies, who depend on Java for business critical applications, are turning to Scala to boost their development productivity, applications scalability and overall reliability.

** Scala is object-oriented

Scala is a pure object-oriented language in the sense that every value is an object. Types and behavior of objects are described by classes and traits which will be explained in subsequent chapters.

Classes are extended by subclassing and a flexible mixin-based composition mechanism as a clean replacement for multiple inheritance.
Scala is functional

** Scala is also a functional language 
Scala is also a functional language in the sense that every function is a value and every value is an object so ultimately every function is an object.

Scala provides a lightweight syntax for defining anonymous functions, it supports higher-order functions, it allows functions to be nested, and supports currying. These concepts will be explained in subsequent chapters.

** Scala is statically typed

Scala, unlike some of the other statically typed languages (C, Pascal, Rust, etc.), does not expect you to provide redundant type information. You don't have to specify a type in most cases, and you certainly don't have to repeat it.

** Scala runs on the JVM

Scala is compiled into Java Byte Code which is executed by the Java Virtual Machine (JVM). This means that Scala and Java have a common runtime platform. You can easily move from Java to Scala.

The Scala compiler compiles your Scala code into Java Byte Code, which can then be executed by the 'scala' command. The 'scala' command is similar to the java command, in that it executes your compiled Scala code.
Scala can Execute Java Code

** Can use classes of Java SDK
Scala enables you to use all the classes of the Java SDK and also your own custom Java classes, or your favorite Java open source projects.
Scala can do Concurrent & Synchronize processing

** Type safe, immutable stuff, concurrency, parallelism
   Scala allows you to express general programming patterns in an effective way. It reduces the number of lines and helps the programmer to code in a type-safe way. It allows you to write codes in an immutable manner, which makes it easy to apply concurrency and parallelism (Synchronize).

** Scala vs Java


Scala has a set of features that completely differ from Java. Some of these are −

    All types are objects
    Type inference
    Nested Functions
    Functions are objects
    Domain specific language (DSL) support
    Traits
    Closures
    Concurrency support inspired by Erlang

Scala Web Frameworks

Scala is being used everywhere and importantly in enterprise web applications. You can check a few of the most popular Scala web frameworks −

    The Lift Framework

    The Play framework

    The Bowler framework

* Environment
#+BEGIN_SRC sh :results output
2>&1 java -version
which java
2>&1 scala -version
#+END_SRC

#+RESULTS:
: openjdk version "1.8.0_131"
: OpenJDK Runtime Environment (build 1.8.0_131-8u131-b11-2ubuntu1.16.04.3-b11)
: OpenJDK 64-Bit Server VM (build 25.131-b11, mixed mode)
: /usr/lib/jvm/java-8-openjdk-amd64/bin/java
: Scala code runner version 2.11.6 -- Copyright 2002-2013, LAMP/EPFL

* Simple concepts
If you have a good understanding on Java, then it will be very easy for you to learn Scala. The biggest syntactic difference between Scala and Java is that the 
** ';' line end character is optional.

When we consider a Scala program, it can be defined as a collection of objects that communicate via invoking each other’s methods. Let us now briefly look into what do class, object, methods and instance variables mean.
** Object
    Object − Objects have states and behaviors. An object is an instance of a class. Example − A dog has states - color, name, breed as well as behaviors - wagging, barking, and eating.
** Class
    Class − A class can be defined as a template/blueprint that describes the behaviors/states that are related to the class.
** Methods
    Methods − A method is basically a behavior. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.
** Fields
    Fields − Each object has its unique set of instance variables, which are called fields. An object's state is created by the values assigned to these fields.
** Closure
    Closure − A closure is a function, whose return value depends on the value of one or more variables declared outside this function.
** Traits
    Traits − A trait encapsulates method and field definitions, which can then be reused by mixing them into classes. Traits are used to define object types by specifying the signature of the supported methods.

* Hello world in scala

** Normal mode
#+BEGIN_SRC scala :results output
println("hello")
#+END_SRC

#+RESULTS:
: hello


** Script mode
#+BEGIN_SRC scala :results output :tangle /tmp/HelloWorld.scala
object HelloWorld {
   /* This is my first scala program.  
   * This will print 'Hello World' as the output
   */
   def main(args: Array[String]) {
      println("Hello, world!") // prints Hello World
   }
}

#+END_SRC

#+RESULTS:
: Hello, world!


** How to compile
\> scalac /tmp/hello.scala
\> scala hello

#+BEGIN_SRC sh  :results output
cd /tmp
scalac HelloWorld.scala
scala HelloWorld

#+END_SRC

#+RESULTS:
: Hello, world!

* Basic syntax
Basic Syntax

The following are the basic syntaxes and coding conventions in Scala programming.

** Case sensitivity
    Case Sensitivity − Scala is case-sensitive, which means identifier Hello and hello would have different meaning in Scala.

** Class names
    Class Names − For all class names, the first letter should be in Upper Case. If several words are used to form a name of the class, each inner word's first letter should be in Upper Case.

    Example − class MyFirstScalaClass.

** Method names
    Method Names − All method names should start with a Lower Case letter. If multiple words are used to form the name of the method, then each inner word's first letter should be in Upper Case.

    Example − def myMethodName()

** Program file name
    Program File Name − Name of the program file should exactly match the object name. When saving the file you should save it using the object name (Remember Scala is case-sensitive) and append ‘.scala’ to the end of the name. (If the file name and the object name do not match your program will not compile).

    Example − Assume 'HelloWorld' is the object name. Then the file should be saved as 'HelloWorld.scala'.

    def main(args: Array[String]) − Scala program processing starts from the main() method which is a mandatory part of every Scala Program.

** Scala Identifiers

All Scala components require names. Names used for objects, classes, variables and methods are called identifiers. A keyword cannot be used as an identifier and identifiers are case-sensitive. Scala supports four types of identifiers.

*** Alphanumeric Identifiers

An alphanumeric identifier starts with a letter or an underscore, which can be followed by further letters, digits, or underscores. The '$' character is a reserved keyword in Scala and should not be used in identifiers.

Following are legal alphanumeric identifiers −

age, salary, _value,  __1_value

Following are illegal identifiers −

$salary, 123abc, -salary

*** Operator Identifiers

An operator identifier consists of one or more operator characters. Operator characters are printable ASCII characters such as +, :, ?, ~ or #.

Following are legal operator identifiers −

+ ++ ::: <?> :>

The Scala compiler will internally "mangle" operator identifiers to turn them into legal Java identifiers with embedded $ characters. For instance, the identifier :-> would be represented internally as $colon$minus$greater.
Mixed Identifiers

A mixed identifier consists of an alphanumeric identifier, which is followed by an underscore and an operator identifier.

Following are legal mixed identifiers −

unary_+,  myvar_=

Here, unary_+ used as a method name defines a unary + operator and myvar_= used as method name defines an assignment operator (operator overloading).
Literal Identifiers

A literal identifier is an arbitrary string enclosed in back ticks (` . . . `).

Following are legal literal identifiers −

`x` `<clinit>` `yield`

** Scala Keywords

The following list shows the reserved words in Scala. These reserved words may not be used as constant or variable or any other identifier names.
abstract 	case 	catch 	class
def 	do 	else 	extends
false 	final 	finally 	for
forSome 	if 	implicit 	import
lazy 	match 	new 	Null
object 	override 	package 	private
protected 	return 	sealed 	super
this 	throw 	trait 	Try
true 	type 	val 	Var
while 	with 	yield 	 
- 	: 	= 	=>
<- 	<: 	<% 	>:
# 	@ 		

** Comments in Scala

Scala supports single-line and multi-line comments very similar to Java. Multi-line comments may be nested, but are required to be properly nested. All characters available inside any comment are ignored by Scala compiler.

object HelloWorld {
   /* This is my first java program.  
    * This will print 'Hello World' as the output
    * This is an example of multi-line comments.
    */
   def main(args: Array[String]) {
      // Prints Hello World
      // This is also an example of single line comment.
      println("Hello, world!") 
   }
}

** Blank Lines and Whitespace

A line containing only whitespace, possibly with a comment, is known as a blank line, and Scala totally ignores it. Tokens may be separated by whitespace characters and/or comments.
Newline Characters

Scala is a line-oriented language where statements may be terminated by semicolons (;) or newlines. A semicolon at the end of a statement is usually optional. You can type one if you want but you don't have to if the statement appears by itself on a single line. On the other hand, a semicolon is required if you write multiple statements on a single line. Below syntax is the usage of multiple statements.

val s = "hello"; println(s)

** Scala Packages

A package is a named module of code. For example, the Lift utility package is net.liftweb.util. The package declaration is the first non-comment line in the source file as follows −

package com.liftcode.stuff

Scala packages can be imported so that they can be referenced in the current compilation scope. The following statement imports the contents of the scala.xml package −

import scala.xml._

You can import a single class and object, for example, HashMap from the scala.collection.mutable package −

import scala.collection.mutable.HashMap

You can import more than one class or object from a single package, for example, TreeMap and TreeSet from the scala.collection.immutable package −

import scala.collection.immutable.{TreeMap, TreeSet}

** Apply Dynamic

A marker trait that enables dynamic invocations. Instances x of this trait allow method invocations x.meth(args) for arbitrary method names meth and argument lists args as well as field accesses x.field for arbitrary field namesfield. This feature is introduced in Scala-2.10.

If a call is not natively supported by x (i.e. if type checking fails), it is rewritten according to the following rules −

foo.method("blah") ~~> foo.applyDynamic("method")("blah")
foo.method(x = "blah") ~~> foo.applyDynamicNamed("method")(("x", "blah"))
foo.method(x = 1, 2) ~~> foo.applyDynamicNamed("method")(("x", 1), ("", 2))
foo.field ~~> foo.selectDynamic("field")
foo.varia = 10 ~~> foo.updateDynamic("varia")(10)
foo.arr(10) = 13 ~~> foo.selectDynamic("arr").update(10, 13)
foo.arr(10) ~~> foo.applyDynamic("arr")(10)


* Data types
Scala has all the same data types as Java, with the same memory footprint and precision. Following is the table giving details about all the data types available in Scala −
Sr.No 	Data Type & Description
1 	

** Byte


8 bit signed value. Range from -128 to 127
2 	

** Short

16 bit signed value. Range -32768 to 32767
3 	

** Int

32 bit signed value. Range -2147483648 to 2147483647
4 	

** Long

64 bit signed value. -9223372036854775808 to 9223372036854775807
5 	

** Float

32 bit IEEE 754 single-precision float
6 	

** Double

64 bit IEEE 754 double-precision float
7 	

** Char

16 bit unsigned Unicode character. Range from U+0000 to U+FFFF
8 	

** String

A sequence of Chars
9 	

** Boolean

Either the literal true or the literal false
10 	

** Unit

Corresponds to no value
11 	

** Null

null or empty reference
12 	

** Nothing

The subtype of every other type; includes no values
13 	

** Any

The supertype of any type; any object is of type Any
14 	

** AnyRef

The supertype of any reference type

All the data types listed above are objects. There are no primitive types like in Java. This means that you can call methods on an Int, Long, etc.

** Scala Basic Literals

The rules Scala uses for literals are simple and intuitive. This section explains all basic Scala Literals.

*** Integral Literals

Integer literals are usually of type Int, or of type Long when followed by a L or l suffix. Here are some integer literals −

0
035
21 
0xFFFFFFFF 
0777L

*** Floating Point Literal

Floating point literals are of type Float when followed by a floating point type suffix F or f, and are of type Double otherwise. Here are some floating point literals −

0.0 
1e30f 
3.14159f 
1.0e100
.1

*** Boolean Literals

The Boolean literals true and false are members of type Boolean.
Symbol Literals

*** Symbol literal
A symbol literal 'x is a shorthand for the expression scala.Symbol("x"). Symbol is a case class, which is defined as follows.

package scala
final case class Symbol private (name: String) {
   override def toString: String = "'" + name
}

*** Character Literals

A character literal is a single character enclosed in quotes. The character is either a printable Unicode character or is described by an escape sequence. Here are some character literals −

'a' 
'\u0041'
'\n'
'\t'

*** String Literals

A string literal is a sequence of characters in double quotes. The characters are either printable Unicode character or are described by escape sequences. Here are some string literals −

"Hello,\nWorld!"
"This string contains a \" character."

*** Multi-Line Strings

A multi-line string literal is a sequence of characters enclosed in triple quotes """ ... """. The sequence of characters is arbitrary, except that it may contain three or more consecutive quote characters only at the very end.

Characters must not necessarily be printable; newlines or other control characters are also permitted. Here is a multi-line string literal −

"""the present string
spans three
lines."""

*** Null Values

The null value is of type scala.Null and is thus compatible with every reference type. It denotes a reference value which refers to a special "null" object.

*** Escape Sequences

The following escape sequences are recognized in character and string literals.
Escape Sequences 	Unicode 	Description
\b 	\u0008 	backspace BS
\t 	\u0009 	horizontal tab HT
\n 	\u000c 	formfeed FF
\f 	\u000c 	formfeed FF
\r 	\u000d 	carriage return CR
\" 	\u0022 	double quote "
\' 	\u0027 	single quote .
\\ 	\u005c 	backslash \

A character with Unicode between 0 and 255 may also be represented by an octal escape, i.e., a backslash '\' followed by a sequence of up to three octal characters. Following is the example to show few escape sequence characters −
Example

object Test {
   def main(args: Array[String]) {
      println("Hello\tWorld\n\n" );
   }
} 

When the above code is compiled and executed, it produces the following result −
Output

Hello   World

* Variables 
Variables are nothing but reserved memory locations to store values. This means that when you create a variable, you reserve some space in memory.

Based on the data type of a variable, the compiler allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals, or characters in these variables.

** Variable Declaration

Scala has a different syntax for declaring variables. They can be defined as value, i.e., constant or a variable. Here, myVar is declared using the keyword var. It is a variable that can change value and this is called mutable variable. Following is the syntax to define a variable using var keyword −
Syntax

var myVar : String = "Foo"

Here, myVal is declared using the keyword val. This means that it is a variable that cannot be changed and this is called immutable variable. Following is the syntax to define a variable using val keyword −
Syntax

val myVal : String = "Foo"

** Variable Data Types

The type of a variable is specified after the variable name and before equals sign. You can define any type of Scala variable by mentioning its data type as follows −
Syntax

*** val or val VariableName : DataType = [Initial Value]

If you do not assign any initial value to a variable, then it is valid as follows −
Syntax

var myVar :Int;
val myVal :String;

*** Variable Type Inference

When you assign an initial value to a variable, the Scala compiler can figure out the type of the variable based on the value assigned to it. This is called variable type inference. Therefore, you could write these variable declarations like this −
Syntax

var myVar = 10;
val myVal = "Hello, Scala!";

Here, by default, myVar will be Int type and myVal will become String type variable.

*** Multiple assignments

Scala supports multiple assignments. If a code block or method returns a Tuple (Tuple − Holds collection of Objects of different types), the Tuple can be assigned to a val variable. [Note − We will study Tuples in subsequent chapters.]
Syntax

val (myVar1: Int, myVar2: String) = Pair(40, "Foo")

And the type inference gets it right −
Syntax

val (myVar1, myVar2) = Pair(40, "Foo")

Example Program

The following is an example program that explains the process of variable declaration in Scala. This program declares four variables — two variables are defined with variable declaration and remaining two are without variable declaration.
Example

#+BEGIN_SRC scala :results output
object Demo {
   def main(args: Array[String]) {
      var myVar :Int = 10;
      val myVal :String = "Hello Scala with datatype declaration.";
      var myVar1 = 20;
      val myVal1 = "Hello Scala new without datatype declaration.";
      
      println(myVar); println(myVal); println(myVar1); 
      println(myVal1);
   }
}

#+END_SRC

#+RESULTS:
: 10
: Hello Scala with datatype declaration.
: 20
: Hello Scala new without datatype declaration.


Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

10
Hello Scala with datatype declaration.
20
Hello Scala without datatype declaration.

*** Variable Scope

Variables in Scala can have three different scopes depending on the place where they are being used. They can exist as fields, as method parameters and as local variables. Below are the details about each type of scope.

**** Fields

Fields are variables that belong to an object. The fields are accessible from inside every method in the object. Fields can also be accessible outside the object depending on what access modifiers the field is declared with. Object fields can be both mutable and immutable types and can be defined using either var or val.

**** Method Parameters

Method parameters are variables, which are used to pass the value inside a method, when the method is called. Method parameters are only accessible from inside the method but the objects passed in may be accessible from the outside, if you have a reference to the object from outside the method. Method parameters are always immutable which are defined by val keyword.

**** Local Variables

Local variables are variables declared inside a method. Local variables are only accessible from inside the method, but the objects you create may escape the method if you return them from the method. Local variables can be both mutable and immutable types and can be defined using either var or val.

* Classes and Objects
This chapter takes you through how to use classes and objects in Scala programming. A class is a blueprint for objects. Once you define a class, you can create objects from the class blueprint with the keyword new. Through the object you can use all functionalities of the defined class.

The following diagram demonstrates the class and object by taking an example of class student, which contains the member variables (name and roll no) and member methods (setName() and setRollNo()). Finally all are members of the class. Class is a blue print and objects are real here. In the following diagram, Student is a class and Harini, John, and Maria are the objects of Student class, those are having name and roll-number.
Scala Classes and Objects
Basic Class

Following is a simple syntax to define a basic class in Scala. This class defines two variables x and y and a method: move, which does not return a value. Class variables are called, fields of the class and methods are called class methods.

The class name works as a class constructor which can take a number of parameters. The above code defines two constructor arguments, xc and yc; they are both visible in the whole body of the class.

** Syntax

class Point(xc: Int, yc: Int) {
   var x: Int = xc
   var y: Int = yc

   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
      println ("Point x location : " + x);
      println ("Point y location : " + y);
   }
}

As mentioned earlier in this chapter, you can create objects using a keyword new and then you can access class fields and methods as shown below in the example −

** Example
I am not sure why this does not work directly but when we run it from outside it works.
Right now results are not being printed directly.
Investigate this later.

#+BEGIN_SRC scala :tangle yes :tangle /tmp/Demo.scala :results output
import java.io._

class Point(val xc: Int, val yc: Int) {
   var x: Int = xc
   var y: Int = yc
   
   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
      println ("Point x location : " + x);
      println ("Point y location : " + y);
   }
}

object Demo {
   def main(args: Array[String]) {
      val pt = new Point(10, 20);

      // Move to a new location
      pt.move(10, 10);

   }
}

#+END_SRC

#+RESULTS:


#+BEGIN_SRC sh :results output
cd /tmp
scalac Demo.scala
scala Demo
#+END_SRC

#+RESULTS:
: Point x location : 20
: Point y location : 30

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

Point x location : 20
Point y location : 30

** Extending a Class

You can extend a base Scala class and you can design an inherited class in the same way you do it in Java (use extends key word), but there are two restrictions: method overriding requires the override keyword, and only the primary constructor can pass parameters to the base constructor. Let us extend our above class and add one more class method.
Example

Let us take an example of two classes Point class (as same example as above) and Location class is inherited class using extends keyword. Such an ‘extends’ clause has two effects: it makes Location class inherit all non-private members from Point class, and it makes the type Location a subtype of the type Point class. So here the Point class is called superclass and the class Location is called subclass. Extending a class and inheriting all the features of a parent class is called inheritance but Scala allows the inheritance from just one class only.

Note − Methods move() method in Point class and move() method in Location class do not override the corresponding definitions of move since they are different definitions (for example, the former take two arguments while the latter take three arguments).

Try the following example program to implement inheritance.

#+BEGIN_SRC scala :results output :tangle yes :tangle /tmp/Inheritance.scala
import java.io._

class Point(val xc: Int, val yc: Int) {
   var x: Int = xc
   var y: Int = yc
   
   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
      println ("Point x location : " + x);
      println ("Point y location : " + y);
   }
}

class Location(override val xc: Int, override val yc: Int,
   val zc :Int) extends Point(xc, yc){
   var z: Int = zc

   def move(dx: Int, dy: Int, dz: Int) {
      x = x + dx
      y = y + dy
      z = z + dz
      println ("Point x location : " + x);
      println ("Point y location : " + y);
      println ("Point z location : " + z);
   }
}

object Inheritance {
   def main(args: Array[String]) {
      val loc = new Location(10, 20, 15);

      // Move to a new location
      loc.move(10, 10, 5);
   }
}

#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :results output
cd /tmp

scalac Inheritance.scala
scala Inheritance

#+END_SRC

#+RESULTS:
: Point x location : 20
: Point y location : 30
: Point z location : 20

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Inheritance.scala
\>scala Inheritance

Output

Point x location : 20
Point y location : 30
Point z location : 20

** Implicit Classes

Implicit classes allow implicit conversations with class’s primary constructor when the class is in scope. Implicit class is a class marked with ‘implicit’ keyword. This feature is introduced in Scala 2.10.

Syntax − The following is the syntax for implicit classes. Here implicit class is always in the object scope where all method definitions are allowed because implicit class cannot be a top level class.
Syntax

object <object name> {
   implicit class <class name>(<Variable>: Data type) {
      def <method>(): Unit =
   }
}

Example

Let us take an example of an implicit class named IntTimes with the method times(). It means the times () contain a loop transaction that will execute the given statement in number of times that we give. Let us assume the given statement is “4 times println (“Hello”)” means the println (“”Hello”) statement will execute 4 times.

The following is the program for the given example. In this example two object classes are used (Run and Demo) so that we have to save those two classes in different files with their respective names as follows.

Run.scala − Save the following program in Run.scala.
#+BEGIN_SRC scala :results output :tangle yes :tangle /tmp/Run.scala
object Run {
   implicit class IntTimes(x: Int) {
      def times [A](f: =>A): Unit = {
         def loop(current: Int): Unit =
         
         if(current > 0){
            f
            loop(current - 1)
         }
         loop(x)
      }
   }
}

#+END_SRC

Demo.scala − Save the following program in Demo.scala.

#+BEGIN_SRC scala :results output :tangle yes :tangle /tmp/Demo1.scala
import Run._

object Demo1 {
   def main(args: Array[String]) {
      3 times println("hello")
   }
}

#+END_SRC

#+RESULTS:


#+BEGIN_SRC sh :results output
cd /tmp
scalac Run.scala
scalac Demo1.scala
scala Demo1

#+END_SRC

#+RESULTS:
: hello
: hello
: hello

The following commands are used to compile and execute these two programs.
Command

\>scalac Run.scala
\>scalac Demo.scala
\>scala Demo

Output

Hello
Hello
Hello
Hello

Note −

    Implicit classes must be defined inside another class/object/trait (not in top level).

    Implicit classes may only take one non –implicit argument in their constructor.

    Implicit classes may not be any method, member or object in scope with the same name as the implicit class.

** Singleton Objects

Scala is more object-oriented than Java because in Scala, we cannot have static members. Instead, Scala has singleton objects. A singleton is a class that can have only one instance, i.e., Object. You create singleton using the keyword object instead of class keyword. Since you can't instantiate a singleton object, you can't pass parameters to the primary constructor. You already have seen all the examples using singleton objects where you called Scala's main method.

Following is the same example program to implement singleton.
Example

import java.io._

class Point(val xc: Int, val yc: Int) {
   var x: Int = xc
   var y: Int = yc
   
   def move(dx: Int, dy: Int) {
      x = x + dx
      y = y + dy
   }
}

object Demo {
   def main(args: Array[String]) {
      val point = new Point(10, 20)
      printPoint

      def printPoint{
         println ("Point x location : " + point.x);
         println ("Point y location : " + point.y);
      }
   }
}

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

Point x location : 10
Point y location : 20

** Access modifiers
This chapter takes you through the Scala access modifiers. Members of packages, classes or objects can be labeled with the access modifiers private and protected, and if we are not using either of these two keywords, then access will be assumed as public. These modifiers restrict accesses to the members to certain regions of code. To use an access modifier, you include its keyword in the definition of members of package, class or object as we will see in the following section.

*** Private Members

A private member is visible only inside the class or object that contains the member definition.

Following is the example code snippet to explain Private member −
Example

class Outer {
   class Inner {
      private def f() { println("f") }
      
      class InnerMost {
         f() // OK
      }
   }
   (new Inner).f() // Error: f is not accessible
}

In Scala, the access (new Inner). f() is illegal because f is declared private in Inner and the access is not from within class Inner. By contrast, the first access to f in class Innermost is OK, because that access is contained in the body of class Inner. Java would permit both accesses because it lets an outer class access private members of its inner classes.

*** Protected Members

A protected member is only accessible from subclasses of the class in which the member is defined.

Following is the example code snippet to explain protected member −
Example

package p {
   class Super {
      protected def f() { println("f") }
   }
   
   class Sub extends Super {
      f()
   }
   
   class Other {
      (new Super).f() // Error: f is not accessible
   }
}

The access to f in class Sub is OK because f is declared protected in ‘Super’ class and ‘Sub’ class is a subclass of Super. By contrast the access to f in ‘Other’ class is not permitted, because class ‘Other’ does not inherit from class ‘Super’. In Java, the latter access would be still permitted because ‘Other’ class is in the same package as ‘Sub’ class.
Public Members

Unlike private and protected members, it is not required to specify Public keyword for Public members. There is no explicit modifier for public members. Such members can be accessed from anywhere.

Following is the example code snippet to explain public member −
Example

class Outer {
   class Inner {
      def f() { println("f") }
      
      class InnerMost {
         f() // OK
      }
   }
   (new Inner).f() // OK because now f() is public
}

*** Scope of Protection

Access modifiers in Scala can be augmented with qualifiers. A modifier of the form private[X] or protected[X] means that access is private or protected "up to" X, where X designates some enclosing package, class or singleton object.

Consider the following example −
Example

package society {
   package professional {
      class Executive {
         private[professional] var workDetails = null
         private[society] var friends = null
         private[this] var secrets = null

         def help(another : Executive) {
            println(another.workDetails)
            println(another.secrets) //ERROR
         }
      }
   }
}

Note − the following points from the above example −

    Variable workDetails will be accessible to any class within the enclosing package professional.

    Variable friends will be accessible to any class within the enclosing package society.

    Variable secrets will be accessible only on the implicit object within instance methods (this).

** Operators
An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Scala is rich in built-in operators and provides the following types of operators −

    Arithmetic Operators
    Relational Operators
    Logical Operators
    Bitwise Operators
    Assignment Operators

This chapter will examine the arithmetic, relational, logical, bitwise, assignment and other operators one by one.

*** Arithmetic Operators

The following arithmetic operators are supported by Scala language. For example, let us assume variable A holds 10 and variable B holds 20, then −

Show Examples
Operator 	Description 	Example
+ 	Adds two operands 	A + B will give 30
- 	Subtracts second operand from the first 	A - B will give -10
\* 	Multiplies both operands 	A * B will give 200
/ 	Divides numerator by de-numerator 	B / A will give 2
% 	Modulus operator finds the remainder after division of one number by another 	B % A will give 0

*** Relational Operators

The following relational operators are supported by Scala language. For example let us assume variable A holds 10 and variable B holds 20, then −

Show Examples
Operator 	Description 	Example
== 	Checks if the values of two operands are equal or not, if yes then condition becomes true. 	(A == B) is not true.
!= 	Checks if the values of two operands are equal or not, if values are not equal then condition becomes true. 	(A != B) is true.
> 	Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true. 	(A > B) is not true.
< 	Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true. 	(A < B) is true.
>= 	Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true. 	(A >= B) is not true.
<= 	Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true. 	(A <= B) is true.

*** Logical Operators

The following logical operators are supported by Scala language. For example, assume variable A holds 1 and variable B holds 0, then −

Show Examples
Operator 	Description 	Example
&& 	It is called Logical AND operator. If both the operands are non zero then condition becomes true. 	(A && B) is false.
\|| 	It is called Logical OR Operator. If any of the two operands is non zero then condition becomes true. 	(A || B) is true.
! 	It is called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false. 	!(A && B) is true.

*** Bitwise Operators

Bitwise operator works on bits and perform bit by bit operation. The truth tables for &, |, and ^ are as follows −
p 	q 	p & q 	p | q 	p ^ q
0 	0 	0 	0 	0
0 	1 	0 	1 	1
1 	1 	1 	1 	0
1 	0 	0 	1 	1

Assume if A = 60; and B = 13; now in binary format they will be as follows −

A = 0011 1100
B = 0000 1101
-----------------------
A&B = 0000 1100
A|B = 0011 1101
A^B = 0011 0001
~A = 1100 0011

The Bitwise operators supported by Scala language is listed in the following table. Assume variable A holds 60 and variable B holds 13, then −

Show Examples
Operator 	Description 	Example
& 	Binary AND Operator copies a bit to the result if it exists in both operands. 	(A & B) will give 12, which is 0000 1100
\| 	Binary OR Operator copies a bit if it exists in either operand. 	(A | B) will give 61, which is 0011 1101
^ 	Binary XOR Operator copies the bit if it is set in one operand but not both. 	(A ^ B) will give 49, which is 0011 0001
~ 	Binary Ones Complement Operator is unary and has the effect of 'flipping' bits. 	(~A ) will give -61, which is 1100 0011 in 2's complement form due to a signed binary number.
<< 	Binary Left Shift Operator. The bit positions of the left operands value is moved left by the number of bits specified by the right operand. 	A << 2 will give 240, which is 1111 0000
>> 	Binary Right Shift Operator. The Bit positions of the left operand value is moved right by the number of bits specified by the right operand. 	A >> 2 will give 15, which is 1111
>>> 	Shift right zero fill operator. The left operands value is moved right by the number of bits specified by the right operand and shifted values are filled up with zeros. 	A >>>2 will give 15 which is 0000 1111

*** Assignment Operators

There are following assignment operators supported by Scala language −

Show Examples
Operator 	Description 	Example
= 	Simple assignment operator, Assigns values from right side operands to left side operand 	C = A + B will assign value of A + B into C
+= 	Add AND assignment operator, It adds right operand to the left operand and assign the result to left operand 	C += A is equivalent to C = C + A
-= 	Subtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand 	C -= A is equivalent to C = C - A
*= 	Multiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand 	C *= A is equivalent to C = C * A
/= 	Divide AND assignment operator, It divides left operand with the right operand and assign the result to left operand 	C /= A is equivalent to C = C / A
%= 	Modulus AND assignment operator, It takes modulus using two operands and assign the result to left operand 	C %= A is equivalent to C = C % A
<<= 	Left shift AND assignment operator 	C <<= 2 is same as C = C << 2
>>= 	Right shift AND assignment operator 	C >>= 2 is same as C = C >> 2
&= 	Bitwise AND assignment operator 	C &= 2 is same as C = C & 2
^= 	bitwise exclusive OR and assignment operator 	C ^= 2 is same as C = C ^ 2
\|= 	bitwise inclusive OR and assignment operator 	C |= 2 is same as C = C | 2
Operators Precedence in Scala

Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator −

For example, x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.

Take a look at the following table. Operators with the highest precedence appear at the top of the table and those with the lowest precedence appear at the bottom. Within an expression, higher precedence operators will be evaluated first.
Category 	Operator 	Associativity
Postfix 	() [] 	Left to right
Unary 	! ~ 	Right to left
Multiplicative 	* / % 	Left to right
Additive 	+ - 	Left to right
Shift 	>> >>> << 	Left to right
Relational 	> >= < <= 	Left to right
Equality 	== != 	Left to right
Bitwise AND 	& 	Left to right
Bitwise XOR 	^ 	Left to right
Bitwise OR 	| 	Left to right
Logical AND 	&& 	Left to right
Logical OR 	|| 	Left to right
Assignment 	= += -= *= /= %= >>= <<= &= ^= |= 	Right to left
Comma 	, 	Left to right

** Conditionals if else

This chapter takes you through the conditional construction statements in Scala programming. Following is the general form of a typical decision making IF...ELSE structure found in most of the programming languages.
Flow Chart

The following is a flow chart diagram for conditional statement.
Scala IF...ELSE Structure
if Statement

‘if’ statement consists of a Boolean expression followed by one or more statements.

*** Syntax

The syntax of an ‘if’ statement is as follows.

if(Boolean_expression) {
   // Statements will execute if the Boolean expression is true
}

If the Boolean expression evaluates to true then the block of code inside the ‘if’ expression will be executed. If not, the first set of code after the end of the ‘if’ expression (after the closing curly brace) will be executed.

Try the following example program to understand conditional expressions (if expression) in Scala Programming Language.
Example

object Demo {
   def main(args: Array[String]) {
      var x = 10;

      if( x < 20 ){
         println("This is if statement");
      }
   }
}

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

This is if statement

*** If-else Statement

An ‘if’ statement can be followed by an optional else statement, which executes when the Boolean expression is false.
Syntax

The syntax of a if...else is −

if(Boolean_expression){
   //Executes when the Boolean expression is true
} else{
   //Executes when the Boolean expression is false
}

Try the following example program to understand conditional statements (if- else statement) in Scala Programming Language.
Example

object Demo {
   def main(args: Array[String]) {
      var x = 30;

      if( x < 20 ){
         println("This is if statement");
      } else {
         println("This is else statement");
      }
   }
}

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

This is else statement

*** If-else-if-else Statement

An 'if' statement can be followed by an optional 'else if...else' statement, which is very useful to test various conditions using single if...else if statement.

When using if , else if , else statements there are few points to keep in mind.

    An 'if' can have zero or one else's and it must come after any else if's.

    An 'if' can have zero to many else if's and they must come before the else.

    Once an else if succeeds, none of he remaining else if's or else's will be tested.

Syntax

The following is the syntax of an ‘if...else if...else’ is as follows −

if(Boolean_expression 1){
   //Executes when the Boolean expression 1 is true
} else if(Boolean_expression 2){
   //Executes when the Boolean expression 2 is true
} else if(Boolean_expression 3){
   //Executes when the Boolean expression 3 is true
} else {
   //Executes when the none of the above condition is true.
}

Try the following example program to understand conditional statements (if- else- if- else statement) in Scala Programming Language.
Example

object Demo {
   def main(args: Array[String]) {
      var x = 30;

      if( x == 10 ){
         println("Value of X is 10");
      } else if( x == 20 ){
         println("Value of X is 20");
      } else if( x == 30 ){
         println("Value of X is 30");
      } else{
         println("This is else statement");
      }
   }
}

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

Value of X is 30

*** Nested if-else Statement

It is always legal to nest if-else statements, which means you can use one if or else-if statement inside another if or else-if statement.
Syntax

The syntax for a nested if-else is as follows −

if(Boolean_expression 1){
   //Executes when the Boolean expression 1 is true
   
   if(Boolean_expression 2){
      //Executes when the Boolean expression 2 is true
   }
}

Try the following example program to understand conditional statements (nested- if statement) in Scala Programming Language.
Example

object Demo {
   def main(args: Array[String]) {
      var x = 30;
      var y = 10;
      
      if( x == 30 ){
         if( y == 10 ){
            println("X = 30 and Y = 10");
         }
      }
   }
}

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

X = 30 and Y = 10

** Loop constructs
This chapter takes you through the loop control structures in Scala programming languages.

There may be a situation, when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.

Programming languages provide various control structures that allow for more complicated execution paths.

A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages −
Flow Chart
Loop Architecture

Scala programming language provides the following types of loops to handle looping requirements. Click the following links in the table to check their detail.
Sr.No 	Loop Type & Description
1 	

*** while loop

Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.
2 	

object Demo {
   def main(args: Array[String]) {
      // Local variable declaration:
      var a = 10;

      // while loop execution
      while( a < 20 ){
         println( "Value of a: " + a );
         a = a + 1;
      }
   }
}
*** do-while loop

Like a while statement, except that it tests the condition at the end of the loop body.
3

do {
   statement(s);
} 
while( condition ); 	

#+BEGIN_SRC scala :results output
object Demo {
   def main(args: Array[String]) {
      // Local variable declaration:
      var a = 10;

      // do loop execution
      do {
         println( "Value of a: " + a );
         a = a + 1;
      }
      while( a < 20 )
   }
}

#+END_SRC

#+RESULTS:
#+begin_example
Value of a: 10
Value of a: 11
Value of a: 12
Value of a: 13
Value of a: 14
Value of a: 15
Value of a: 16
Value of a: 17
Value of a: 18
Value of a: 19
#+end_example

*** for loop

Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.
Loop Control Statements

Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed. As such Scala does not support break or continue statement like Java does but starting from Scala version 2.8, there is a way to break the loops. Click the following links to check the detail.
Sr.No 	Control Statement & Description
1 	


A for loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times. There are various forms of for loop in Scala which are described below −
Syntax − for loop with ranges

The simplest syntax of for loop with ranges in Scala is −

for( var x <- Range ){
   statement(s);
}

Here, the Range could be a range of numbers and that is represented as i to j or sometime like i until j. The left-arrow ← operator is called a generator, so named because it's generating individual values from a range.

Try the following example program to understand loop control statements (for statement) in Scala Programming Language.
Example

object Demo {
   def main(args: Array[String]) {
      var a = 0;
      
      // for loop execution with a range
      for( a <- 1 to 10){
         println( "Value of a: " + a );
      }
   }
}

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

value of a: 1
value of a: 2
value of a: 3
value of a: 4
value of a: 5
value of a: 6
value of a: 7
value of a: 8
value of a: 9
value of a: 10

Try the following example program to understand loop control statements (for statement) to print loop with the range i until j in Scala Programming Language.
Example

object Demo {
   def main(args: Array[String]) {
      var a = 0;
      
      // for loop execution with a range
      for( a <- 1 until 10){
         println( "Value of a: " + a );
      }
   }
}

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

value of a: 1
value of a: 2
value of a: 3
value of a: 4
value of a: 5
value of a: 6
value of a: 7
value of a: 8
value of a: 9

You can use multiple ranges separated by semicolon (;) within for loop and in that case loop will iterate through all the possible computations of the given ranges. Following is an example of using just two ranges, you can use more than two ranges as well.
Example

object Demo {
   def main(args: Array[String]) {
      var a = 0;
      var b = 0;
      
      // for loop execution with a range
      for( a <- 1 to 3; b <- 1 to 3){
         println( "Value of a: " + a );
         println( "Value of b: " + b );
      }
   }
}

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

Value of a: 1
Value of b: 1
Value of a: 1
Value of b: 2
Value of a: 1
Value of b: 3
Value of a: 2
Value of b: 1
Value of a: 2
Value of b: 2
Value of a: 2
Value of b: 3
Value of a: 3
Value of b: 1
Value of a: 3
Value of b: 2
Value of a: 3
Value of b: 3

Syntax − for Loop with Collections

The following syntax for loop with collections.

for( var x <- List ){
   statement(s);
}

Here, the List variable is a collection type having a list of elements and for loop iterate through all the elements returning one element in x variable at a time.

Try the following example program to understand loop with a collection of numbers. Here we created this collection using List(). We will study collections in a separate chapter. Loop control statements (for statement) in Scala Programming Language.
Example

object Demo {
   def main(args: Array[String]) {
      var a = 0;
      val numList = List(1,2,3,4,5,6);

      // for loop execution with a collection
      for( a <- numList ){
         println( "Value of a: " + a );
      }
   }
}

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

value of a: 1
value of a: 2
value of a: 3
value of a: 4
value of a: 5
value of a: 6

Syntax − for loop with Filters

Scala's for loop allows to filter out some elements using one or more if statement(s). Following is the syntax of for loop along with filters. To add more than one filter to a 'for' expression, separate the filters with semicolons(;).

for( var x <- List
      if condition1; if condition2...
   ){
   statement(s);
}

Try the following example program to understand loop with a filter.
Example

object Demo {
   def main(args: Array[String]) {
      var a = 0;
      val numList = List(1,2,3,4,5,6,7,8,9,10);

      // for loop execution with multiple filters
      for( a <- numList
           if a != 3; if a < 8 ){
         println( "Value of a: " + a );
      }
   }
}

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

value of a: 1
value of a: 2
value of a: 4
value of a: 5
value of a: 6
value of a: 7

Syntax − for loop with yield

You can store return values from a "for" loop in a variable or can return through a function. To do so, you prefix the body of the 'for' expression by the keyword yield. The following is the syntax.
Example

var retVal = for{ var x <- List
   if condition1; if condition2...
}
yield x

Note − the curly braces have been used to keep the variables and conditions and retVal is a variable where all the values of x will be stored in the form of collection.

Try the following example program to understand loop with yield.
Example

object Demo {
   def main(args: Array[String]) {
      var a = 0;
      val numList = List(1,2,3,4,5,6,7,8,9,10);

      // for loop execution with a yield
      var retVal = for{ a <- numList if a != 3; if a < 8 }yield a

      // Now print returned values using another loop.
      for( a <- retVal){
         println( "Value of a: " + a );
      }
   }
}

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

value of a: 1
value of a: 2
value of a: 4
value of a: 5
value of a: 6
value of a: 7


*** break statement

Terminates the loop statement and transfers execution to the statement immediately following the loop.

As such there is no built-in break statement available in Scala but if you are running Scala version 2.8, then there is a way to use break statement. When the break statement is encountered inside a loop, the loop is immediately terminated and program control resumes at the next statement following the loop.
Flow Chart
Scala break statement
Syntax

The following is the syntax for break statement.

// import following package
import scala.util.control._

// create a Breaks object as follows
val loop = new Breaks;

// Keep the loop inside breakable as follows
loop.breakable {
   // Loop will go here
   for(...){
      ....
      
      // Break will go here
      loop.break;
   }
}

Try the following example program to understand break statement.
Example

import scala.util.control._

object Demo {
   def main(args: Array[String]) {
      var a = 0;
      val numList = List(1,2,3,4,5,6,7,8,9,10);

      val loop = new Breaks;
      
      loop.breakable {
         for( a <- numList){
            println( "Value of a: " + a );
            
            if( a == 4 ){
               loop.break;
            }
         }
      }
      println( "After the loop" );
   }
}

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

Value of a: 1
Value of a: 2
Value of a: 3
Value of a: 4
After the loop

Breaking Nested Loops

Existing break has an issue while using for nested loops. Just in case to use break for nested loops, follow this method. This is an example program for breaking nested loops.
Example

import scala.util.control._

object Demo {
   def main(args: Array[String]) {
      var a = 0;
      var b = 0;
      val numList1 = List(1,2,3,4,5);
      val numList2 = List(11,12,13);

      val outer = new Breaks;
      val inner = new Breaks;

      outer.breakable {
         for( a <- numList1){
            println( "Value of a: " + a );
            
            inner.breakable {
               for( b <- numList2){
                  println( "Value of b: " + b );
                  
                  if( b == 12 ){
                     inner.break;
                  }
               }
            } // inner breakable
         }
      } // outer breakable.
   }
}

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

Value of a: 1
Value of b: 11
Value of b: 12
Value of a: 2
Value of b: 11
Value of b: 12
Value of a: 3
Value of b: 11
Value of b: 12
Value of a: 4
Value of b: 11
Value of b: 12
Value of a: 5
Value of b: 11
Value of b: 12


*** The infinite Loop

A loop becomes an infinite loop if a condition never becomes false. If you are using Scala, the while loop is the best way to implement infinite loop.

The following program implements infinite loop.
Example

object Demo {
   def main(args: Array[String]) {
      var a = 10;
      
      // An infinite loop.
      while( true ){
         println( "Value of a: " + a );
      }
   }
}

Save the above program in Demo.scala. The following commands are used to compile and execute this program.
Command

\>scalac Demo.scala
\>scala Demo

Output

If you will execute above code, it will go in infinite loop which you can terminate by pressing Ctrl + C keys.

Value of a: 10
Value of a: 10
Value of a: 10
Value of a: 10
…………….

** Functions

** Closures

** Strings

** Arrays

** Collections

** Traits

** Pattern matching

** Regular expressions

** Exception handling

** Extractors

** File I/O
